Solidity支持多重继承。

合约可以使用"is"关键字继承其他合约。 

将被子合约覆盖的函数必须声明为virtual。 

将要覆盖父函数的函数必须使用关键字 override。

 继承的顺序很重要。 您必须按照从“最基本的”到“最派生的”的顺序列出父合约。

## 继承

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

contract A {
    function foo() public pure returns (string memory) {
        return "A";
    }

    function bar() public pure returns (string memory) {
        return "A";
    }
    
    function baz() public pure returns (string memory) {
        return "A";
    }
}

contract B {
    function foo() public pure returns (string memory) {
        return "B";
    }

    function bar() public pure returns (string memory) {
        return "B";
    }
}

```

想让B继承A



virtual: 说明可以继承且可以被改变

override：重写

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

contract A {
    function foo() public pure virtual returns (string memory) {
        return "A";
    }

    function bar() public pure virtual returns (string memory) {
        return "A";
    }

    function baz() public pure returns (string memory) {
        return "A";
    }
}

contract B is A {
    function foo() public pure override returns (string memory) {
        return "B";
    }

    function bar() public pure virtual override returns (string memory) {
        return "B";
    }
}

contract C is B {
    function bar() public pure override returns (string memory) {
        return "C";
    }
}

```





## 套娃继承

 

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;
/*
     X
   /  |
  Y   | 
   \  |
     Z
// order of most base like to derived
// X Y Z
*/
contract X {
    function foo() public pure virtual returns (string memory) {
        return "X";
    }

    function bar() public pure virtual returns (string memory) {
        return "X";
    }

    function x() public pure returns (string memory) {
        return "X";
    }
}

contract Y is X {
    function foo() public pure virtual override returns (string memory) {
        return "Y";
    }

    function bar() public pure virtual override returns (string memory) {
        return "Y";
    }

    function y() public pure returns (string memory) {
        return "y";
    }
}

contract Z is X, Y {
    function foo() public pure override(X, Y) returns (string memory) {
        return "Z";
    }

    function bar() public pure override(X, Y) returns (string memory) {
        return "Z";
    }
}

```





## 继承顺序

```solidity
/*
     X
   /  \
  Y    A
  |    |
  |    B
   \   |
     Z
// order of most base like to derived
// X, Y, A, B, Z
*/
```



## Shadowing Inherited State Variables

Unlike functions, state variables cannot be overridden by re-declaring it in the child contract.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

contract A {
    string public name = "Contract A";

    function getName() public view returns (string memory) {
        return name;
    }
}

// Shadowing is disallowed in Solidity 0.6
// This will not compile
// contract B is A {
//     string public name = "Contract B";
// }

contract C is A {
    // This is the correct way to override inherited state variables.
    constructor() {
        name = "Contract C";
    }

    // C.getName returns "Contract C"
}

```

