### **payable**[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#payable)

- 使用 **payable** 标记的**函数**可以用于发送和接收 Eth。
  - **payable** 意味着在调用这个函数的消息中可以附带 Eth。
- 使用 **payable** 标记的 **地址变量**，允许发送和接收 Eth。

![image-20230923102210429](D:\Workplace\github\LearningWeb3.0\docs\基础知识\Solidity\assets\image-20230923102210429.png)

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract Payable {
    // payable 标记函数
    function deposit1() external payable {}

    function deposit2() external {}

    // payable 标记地址
    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }

    // 通过 balance 属性，来查看余额。
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```



## 接收 ETH

三个关键字

- payable
  - 使用 payable 标记的函数可以用于发送和接收 Eth。
  - 使用 payable 标记的地址变量，允许发送和接收 Eth。
- fallback
  - 一个合约可以最多有一个回退函数。
- receive
  - 一个合约最多有一个 `receive` 函数

fallback 和 receive 不是普通函数，而是新的函数类型，有特别的含义，它们前面不需要加 `function` 这个关键字。加上 `function` 之后，它们就变成了一般的函数，只能按一般函数来去调用。同时 `receive` 和 `fallback` 需要注意 gas 消耗。

本节介绍的是合约如何接收 ETH，至于合约如何发送 ETH，请阅读 [两种形式的地址](https://professional-solidity.readthedocs.io/source/02.type-of-data.html#id24) 这一节。

### payable[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#payable)

- 使用 payable 标记的**函数**可以用于发送和接收 Eth。
  - payable 意味着在调用这个函数的消息中可以附带 Eth。
- 使用 payable 标记的 **地址变量**，允许发送和接收 Eth。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract Payable {
    // payable 标记函数
    function deposit1() external payable {}

    function deposit2() external {}

    // payable 标记地址
    function withdraw() external {
        payable(msg.sender).transfer(address(this).balance);
    }

    // 通过 balance 属性，来查看余额。
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

可以使用 deposit1 存款，但是如果使用 calldata 转账，则会失败，报错 *In order to receive Ether transfer the contract should have either ‘receive’ or payable ‘fallback’ function*，我们接下来介绍 fallback 和 receive。

### fallback[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#fallback)

fallback 函数是调用合约没有的方法时候执行，同时也可以设置为允许接收网络主币。

- 语法

  - 不带参数: `fallback () external [payable]`
  - 带参数: `fallback (bytes calldata input) external [payable] returns (bytes memory output)`
  - 没有`function`关键字。必须是`external`可见性，

  ```
  // function fallback() external payable {}
  // 正确写法不带 function，直接写 fallback，fallback 如果使用 function 修饰，则有警告
  // This function is named "fallback" but is not the fallback function of the contract.
  // If you intend this to be a fallback function, use  "fallback(...) { ... }" without
  // the "function" keyword to define it.
  ```

- fallback 函数类型可以是 `payable`，也可以不是 `payable` 的;

  - 如果不是 `payable` 的，可以往合约发送非转账交易，如果交易里带有转账信息，交易会被 revert；
  - 如果是 `payable` 的，自然也就可以接受转账了。

- 尽管 `fallback` 可以是 payable 的，但并不建议这么做，声明为 `payable` 之后，其所消耗的 gas 最大量就会被限定在 2300。

- 它可以是`virtual`的，可以被重载也可以有修改器（modifier）。

**回退函数在两种情况被调用**：

- 向合约转账；
  - 如果使用 call 转账，会执行 fallback。
  - 如果使用合约内已有的 `deposit` 转账，不会执行 fallback
- 执行合约不存在的方法
  - 就会执行 fallback 函数。（执行合约不存在的方法时执行）

#### 向合约转账[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#id28)

fallback 函数始终会接收数据，但为了同时接收以太时，必须标记为　`payable`。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract Payable {
    event Log(string funName, address from, uint256 value, bytes data);

    function deposit() external payable {}

    // 通过 balance 属性，来查看余额。
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }

    fallback() external payable {
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }
}
```

#### 执行合约不存在的方法[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#id29)

如果在一个对合约调用中，没有其他函数与给定的函数标识符匹配 fallback 会被调用．或者在没有 receive 函数时，而没有提供附加数据对合约调用，那么 fallback 函数会被执行。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract StoneCat {
    uint256 public age = 0;
    event eventFallback(string);

    // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。
    // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符
    fallback() external {
        age++;
        emit eventFallback("fallbak");
    }
}

interface AnimalEat {
    function eat() external returns (string memory);
}

contract Animal {
    function test1(address _addr) external returns (string memory) {
        AnimalEat general = AnimalEat(_addr);
        return general.eat();
    }
    function test2(address _addr) external returns (bool success) {
        AnimalEat general = AnimalEat(_addr);
        (success,) = address(general).call(abi.encodeWithSignature("eat()"));
        require(success);
    }
}
```

上面例子种，执行 StoneCat 合约 calldata，参数 `0x00` 可以成功，但是如果发送了以太币，则会失败，因为没有 paybale。

直接使用方法是不行的，但是可以通过 call 调用，因为 call 不检查，这也官方是不推荐使用 call 的原因。

#### 带参数的 fallback[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#id30)

fallback 可以有输入值和输出值，都是 `bytes` 类型的数据。如果使用了带参数的版本，`input` 将包含发送到合约的完整数据，参数 input 等于`msg.data`，可以省略，并且通过 `output` 返回数据。 返回数据不是 ABI 编码过的数据，相反，它返回不经过修改的数据。与任何其他函数一样，只要有足够的 gas 传递给它，回退函数就可以执行复杂的操作。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract Demo {
    bytes public inputData1;
    bytes public inputData2;

    fallback (bytes calldata input) external  returns (bytes memory output){
        inputData1 = input;
        inputData2 = msg.data; // input 等于 msg.data
        return input;
    }
}
```

⚠️ 如果想要解码输入数据，那么前四个字节用作函数选择器，然后用`abi.decode` 与数组切片语法一起使用来解码 ABI 编码的数据： `(c, d) = abi.decode(_input[4:], (uint256, uint256));`请注意，这仅应作为最后的手段，而应使用对应的函数。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract StoneCat {
    uint256 public age = 0;
    bytes public inputData1;
    bytes public inputData2;
    uint256 public c;
    uint256 public d;

    event eventFallback(string);

    fallback (bytes calldata input) external  returns (bytes memory output){
        age++;
        inputData1 = input;
        inputData2 = msg.data;
        (c, d) = abi.decode(msg.data[4:], (uint256, uint256));
        emit eventFallback("fallbak");
        return input;
    }
}

interface AnimalEat {
    function eat() external returns (string memory);
}

contract Animal {
    function test2(address _addr) external returns (bool success) {
        AnimalEat general = AnimalEat(_addr);
        (success, ) = address(general).call(abi.encodeWithSignature("eat()",123,456));
        require(success);
    }
}
```

### receive 以太函数[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#receive)

receive 只负责接收主币,一个合约最多有一个 `receive` 函数

- 语法 `receive() external payable {}`

  - 没有 `function` 关键字

  ```
    // function receive() external payable {}
    // receive 如果使用 function 修饰，则有如下警告
    // This function is named "receive" but is not the receive function of
    // the contract. If you intend this to be a receive function,
    // use "receive(...) { ... }" without the "function" keyword to define it.
  ```

- 没有参数、没有返回值。

- `external payable` 是必须的

  - receive 函数类型必须是 `payable` 的，并且里面的语句只有在通过外部地址往合约里转账的时候执行。

- 它可以是 `virtual` 的，可以被重载也可以有 修改器(modifier) 。

- 如果没有定义 `接收函数 receive`，就会执行 `fallback` 函数。

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

contract Demo {
    event Log(string funName, address from, uint256 value, bytes data);

    receive() external payable {
        // receive 被调用的时候不存在 msg.data，所以不使用这个，直接用空字符串
        emit Log("receive", msg.sender, msg.value, "");
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

上面例子通过 calldata 执行转账，无参数时候会触发 receive 函数。但是如果有参数，比如`0x00`,则会报错 *‘Fallback’ function is not defined*

在对合约没有任何附加数据调用（通常是对合约转账）是会执行 `receive`函数．例如　通过 `.send()` or `.transfer()`。

声明为 payable 之后，其所消耗的 gas 最大量就会被限定在 2300。除了基础的日志输出之外，进行其他操作的余地很小。下面的操作消耗会操作 2300 gas :

- 写入存储
- 创建合约
- 调用消耗大量 gas 的外部函数
- 发送以太币

扩展阅读 ⚠️: 一个没有 receive 函数的合约，可以作为 *coinbase 交易* （又名*矿工区块回报* ）的接收者或者作为 `selfdestruct` 的目标来接收以太币。一个合约不能对这种以太币转移做出反应，因此也不能拒绝它们。这是 EVM 在设计时就决定好的，而且 Solidity 无法绕过这个问题。这也意味着 `address(this).balance` 可以高于合约中实现的一些手工记帐的总和（例如在 receive 函数中更新的累加器记帐）。

### receive 和 fallback 共存的调用[](https://professional-solidity.readthedocs.io/zh_CN/latest/source/01.hello.html#receive-fallback)

注意：这里 fallback 需要是 `payable` 类型的。如下图:

```
/**

    调用时发送了ETH
            |
判断 msg.data 是否为空
          /     \
        是       否
是否存在 receive   fallbak()
      /   \
    存在   不存在
    /        \
receive()   fallbak()

 */
```

**总结**: 只有 `msg.data` 为空，并且存在 `receive` 的时候，才会运行 `receive`。

如果不存在 `receive` 以太函数，`payable` 的 `fallback` 函数也可以在纯以太转账的时候执行。但是推荐总是定义一个 receive 函数，而不是定义一个 payable 的 fallback 函数。否则会报警告 ⚠️:*Warning: This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.*

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

// 这个合约会保留所有发送给它的以太币，没有办法返还。
contract Demo {
    uint256 public x;
    uint256 public y;

    event Log(string funName, address from, uint256 value, bytes data);

    // 纯转账调用这个函数，例如对每个空empty calldata的调用
    receive() external payable {
        x = 1;
        y = msg.value;
        emit Log("receive", msg.sender, msg.value, "");
    }

    // 除了纯转账外，所有的调用都会调用这个函数．
    // (因为除了 receive 函数外，没有其他的函数).
    // 任何对合约非空calldata 调用会执行回退函数(即使是调用函数附加以太).
    fallback() external payable {
        x = 2;
        y = msg.value;
        emit Log("fallback", msg.sender, msg.value, msg.data);
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

- 输入以太币，然后无参数 calldata 调用
- 输入以太币，然后参数`0x00` 进行 calldata 调用

如果 `receive`函数不存在，但是有 `payable` 的 fallback 回退函数 那么在进行纯以太转账时，fallback 函数会调用.如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太（会抛出异常）。

注意：`receive` 函数可能只有 2300 gas 可以使用（如，当使用 `send` 或`transfer` 时），

⚠️: 一个没有定义 `fallback` 函数或 `receive` 函数的合约，直接接收以太币（没有函数调用，使用 `send` 或 `transfer`）会抛出一个异常， 并返还以太币。所以如果你想让你的合约在任何情况下都可以接收以太币，必须实现 `receive` 函数（使用 `payable fallback` 函数不再推荐，因为它会让借口混淆）。
