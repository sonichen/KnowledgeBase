## Multiple-message secrecy

![image-20240511172933407](assets\image-20240511172933407.png)

多消息机密性是一种密码学概念，指的是在一次通信中，**发送者和接收者可以传递多个消息**，但对于窃听者来说，这些消息是保密的，他们无法推断出这些消息的内容。这种方法通常使用密钥来加密和解密消息，确保通信的安全性和隐私性。

![image-20240511172952701](assets\image-20240511172952701.png)

- `Fix P, A`: 这表示固定了两个函数，P 和 A。
- 定义一个随机实验 PrivKmult，其参数是 A 和 P，取决于输入长度 n
  - 1 在给定输入长度为 n 时，函数 A 输出两个向量，分别是 (m0,1, …, m0,t) 和 (m1,1, …, m1,t)。这些向量中的每个元素是消息。
    - 对于所有的 i，向量 m0,i 和 m1,i 中的元素数量相同。
  - 2 进行了一些密钥生成和加密的操作。首先，生成一个密钥 k。然后，随机选择一个比特 b（可以是 0 或 1）。接着，对于每个 i，使用密钥 k 将消息 mb,i 进行加密，得到密文 ci。
  - 3 最后，调用函数 A，并传入加密后的密文 c1 到 ct。函数 A 尝试推测原始的比特值 b，并输出结果为 b'。如果 A 猜对了比特值 b，且实验结果为 1，则认为函数 A 成功。

如果满足以下条件，则称其为多消息不可区分性（multiple-message indistinguishability）：

![image-20240511181539637](assets\image-20240511181539637.png)

没有加密方案能够满足多消息不可区分性（ multiple-message indistinguishable）。这意味着，在实际情况下，**没有一种加密方案可以确保无论何时发送多个消息时都能保持通信的机密性**。

这个结论暗示了一个重要的假设：我们可能在分析多消息机密性时做了一些假设。具体来说，我们可能假设了加密方案是确定性的（即，相同的明文始终加密成相同的密文），并且不包含状态（即，加密和解密操作不依赖于先前的加密/解密历史）。但是，根据这个结论，我们可以推断出这些假设可能是错误的。

因此，如果我们希望实现多消息不可区分性，我们需要考虑使用随机化方案（**randomized** schemes），而不是仅依赖于确定性且无状态的加密方案。



**Randomized encryption**：这个问题并不是我们定义的一个附属问题 - 如果攻击者能够分辨出同一消息被加密了两次，这确实是一个问题



我们不打算使用multiple message indistinguishability。 

相反，我们会定义一个更强的概念：抗选择明文攻击（CPA-security）。 – 现在，这是一个加密方案应该满足的最低安全性概念。

## CPA-security

### 理解1

![image-20240511182631122](assets\image-20240511182631122.png)

CPA（Chosen-Plaintext Attack）安全性是一种加密方案的安全性概念。其定义如下：

- 固定 P（概率多项式）和 A（概率多项式攻击者）。
- 定义一个随机实验 PrivKCPAA,P(n)：
  1. 生成一个密钥 k。
  2. 攻击者 A 与一个加密预言机 Enck(·) 交互，然后输出相同长度的两个明文 m0 和 m1。
  3. 随机选择一个比特 b（可以是 0 或 1），然后将明文 mb 加密得到密文 c，并将 c 提供给攻击者 A。
  4. A 可以继续与加密预言机 Enck(·) 交互。
  5. A 输出比特值 b'；如果 b = b'，且实验结果为 1，则攻击者 A 成功。

![image-20240511182745689](assets\image-20240511182745689.png)

### 理解2 

实际应用中，大家喜欢重复使用密钥，**希望用一个密钥加密多个消息也不会存在安全问题**。但是，不管是流密码还是分组密码，都不能直接重复使用密钥，因为他们都是确定性算法，也就是说，密钥不变的情况下，相同的明文总是被加密成相同的密文

如果密钥重复使用，攻击者看到相同的密文，虽然不知道明文内容，但是可以知道这两个密文对应的明文内容相同，泄露了明文信息。



**一个对称加密方案被证明是语义安全的，不代表 密钥在被重复使用时也是语义安全的**。**语义安全只考虑了密钥使用一次的安全性**，**不能保证密钥重复使用**时仍然是安全的，因为语义安全模型具有局限性，只考虑攻击者询问一次的情况，不考虑多次询问的情况

提出一个新的安全性定义，以讨论多次询问挑战者时的安全性问题 。引出CPA安全性（选择明文攻击下的语义安全性”CPA安全性 i），语义安全性的升级版 

#### 安全模型

CPA安全性中的攻击者

攻击能力：明文攻击

攻击目标：破坏语义安全性（区分两个明文，区分挑战者返回的密文包含的明文是谁）

定义和语义安全性相似，都是明文攻击下的概念。**不同点就是CPA安全性模型中允许攻击者多次询问挑战者**，因为每次询问时，挑战者都会用密钥加密一个发送过来的明文，模拟了密钥被重复使用时的情况。每次询问时都发送两个明文

![image-20240511160321187](assets\image-20240511160321187.png)

实验0的挑战者收到询问后总是加密m0，实验1的挑战者收到询问后总是加密m1，每次询问时发送的两个明文必须等长度，不同的询问轮次之间明文长度可以不一样

#### 定义

定义（CPA安全性）：设（E, D）是定义在 (K, M, C) 上的对称加密方案，如果在上述安全模型中，对于所有高效的攻击者 A，其优势 Adv 都是可忽略的，则（E, D）是CPA安全的。  



### 如何达到CPA安全性

两个方法

- 加密时引入随机数

- 加密时引入nonce

**加密时引入随机数**

引入随机数后，使得密文的取值不仅依赖于密钥和明文，还依赖于这个随机数。这样，给定相同的明文，由于加密时使用了不同的随机数，密文也就不一样了。基于这种方法的加密体制叫作随机化的加密体制。

**加密时引入nonce**

nonce是一个数值或比特串，在密钥不变的情况下，每个nonce只允许使用一次。引入nonce后，密文的取值不仅依赖于密钥和明文，还依赖于这个nonce。这样，给定相同的明文，由于加密时使用了不同的nonce，密文也就不一样了。

如何选择nonce呢？有两种方法：
(1) nonce可以取为随机数。
(2) nonce可以取为计数器。计数器就是一个在使用时依次增大的数值。比如，加密第一个明文时设nonce为0，加密第二个明文时设nonce为1，加密第三个明文时设nonce为2，依此类推。每加密一个明文就让nonce的值加1，这样就保证nonce不会被重复使用。密钥更新后，nonce的值可以重新设置成0。

不管是引入随机数，还是引入nonce，要想使这两种方法起作用，就必须保证随机数和nonce的取值空间足够大，使得任一随机数和nonce被重复选到的概率可以忽略不计。



在后文会使用这两种方法构造**CBC模式和CTR模式，使得这两种工作模式能达到CPA安全性。**





## PRF - Pseudorandom functions

### 随机函数 Random function

首先把所有定义在 X 到 Y 上的函数集中起来，形成一个集合。这个集合里的每个元素都是一个类似 f 这样的函数，它们的定义域都是 X，值域是 Y。

这个集合记为 **Funs[X, Y]**，它就是**定义在 X 到 Y 上的所有函数的集合**。

很明显，这个集合里一共有 |Y|^|X| 个函数，非常大！

现在，**从 Funs[X, Y] 中随机选择一个函数。这个函数就是“随机函数**”。

需要注意的是，所谓的“**随机函数**”强调的是**这个函数是随机地被选择出来的**。因此，“随机函数”这个概念和函数的输出是否是随机的没有关系。**即使一个函数的输出不是随机的，但只要它被选出的时候是随机选择的，那么它就是“随机函数”**。

### PRF伪随机函数

Informally, a pseudorandom function “looks like” a random function

![image-20240511172318788](assets\image-20240511172318788.png)

对于 PRF，其安全性要求：给定一个随机产生的密钥 k，**函数 F (k,.) 应该看上去“像”是一个定义在 X 到 Y 上的随机函数。** 

![image-20240512141300339](assets\image-20240512141300339.png)

### PRF安全模型

![image-20240511172550954](assets\image-20240511172550954.png)

两个挑战者，一个挑战者随机选择一个密钥f，使得f:=F(k,.)；另一个挑战者控制的f是随机函数。

攻击者A通过探测（攻击者发送x，挑战者返回计算后的y）来判断自己面对的是哪个挑战者，**可以探测多次**。也就是挑战者要分清楚哪个用的是随机函数哪个用的是为随机函数RPF



PRF 的安全性要求，攻击者不能区分开二者。也即，一个安全的 PRF 应该和随机函数是计算上不可区分的。  

设 W0 和 W1 分别表示 A 在实验 EXP(0) 和 EXP(1) 中输出 1 的事件。

攻击者 A 的优势定义为 Adv := |Pr[W0] – Pr[W1]|。

**定义 (安全的 PRF)：如果所有高效的攻击者的优势都是可忽略的，那么该 PRF 是安全的**

### CPA-secure

if F is a pseudorandom function, then this scheme is CPA-secure

## PRP伪随机置换

![image-20240511172710675](assets\image-20240511172710675.png)

PRF和PRP之间最主要的区别是：**PRP是由逆置换的，PRF未必有逆函数**

根据定义，**PRP 是 PRF 的一个子集，任何一个 PRP 本质上也是一个 PRF**。

但是，一个 PRP 是安全的，但它未必是安全的 PRF。



伪随机置换（PRPs）

- 设 f ∈ Funcn。
- **如果 f 是一个双射，则称其为置换，这意味着存在逆函数 f^-1**。
- 记 Permn 为 Funcn 中所有置换的集合。
- 那么 |Permn| 是多少呢？

伪随机置换

- 设 F 是一个保长度的、带密钥的函数。
- 如果对于每个密钥 k，Fk 都是一个置换，并且 Fk 的逆函数 Fk^-1 可以高效地计算，则称 F 为键控置换。
- 如果对于均匀密钥 k ∈ {0,1}^n，Fk 无法与 Permn 中的均匀置换 f 区分开来，则称 F 为（强）伪随机置换。
- 即使攻击者可以查询正向和逆向方向，也是如此。

注意：

- 对于足够大的 n，随机置换无法与随机函数区分开来。
- 因此，在实践中，伪随机置换也是良好的伪随机函数。

## Block ciphers

- 分组密码是伪随机置换PRPs的实际构造。
- 无渐近性质：F: {0,1}^n × {0,1}^m → {0,1}^m，其中 n 和 m 是固定的。
  - n 代表“密钥长度”。
  - m 代表“块长度”。
- 很难区分密钥为 k 的函数 Fk 与 Permm 中均匀的函数 f，即使攻击者的运行时间远远超过 2^n。

作为对称密码的重要组成部分，分组密码的用途非常广。

 它不仅能用于加密，还可以作为基本模块构造诸如流密码、Hash函数、消息认证码（MAC）等密码工具，可谓多才多艺

### 定义

我们称 (E, D) 是定义在 (K, X) 上的分组密码，其中 K 为密钥空间，X 为分组空间。

确定性加密体制

E：加密算法

D：解密算法

K：密钥空间

X：分组空间，x∈X，x称为一个分组

**分组密码的明文空间和密文空间都是相同的集合**，X。分组密码可以加密X中的一个分组，输出的密文也是X中的一个分组，被加密的分组称为明文分组，输出的密文称为密文分组

（E,D）是定义在（K,X）上的分组密码

![image-20240511161832639](assets\image-20240511161832639.png)



![image-20240511162319967](assets\image-20240511162319967.png)

![image-20240511162348369](assets\image-20240511162348369.png)

![image-20240511162410707](assets\image-20240511162410707.png)

### 分组密码的安全性

希望分组密码的安全性比语义安全性还要强一些

![image-20240511163617532](assets\image-20240511163617532.png)

![image-20240511163647086](assets\image-20240511163647086.png)

定义分组密码的安全性

两个挑战者，每个挑战者控制着一个置换f，不同的挑战者用不同的方法选择f

一个挑战者用f，实验0

一个挑战者用随机置换，实验1

攻击者不知道自己面对哪个挑战者，会用“探测”的方法来帮助判断

攻击者目标是猜出自己面对的是哪个挑战者

探测：攻击者发送x，挑战者返回y，攻击者可以用得到的y来作为下一次使用的x

![image-20240511170927238](assets\image-20240511170927238.png)

分组密码的安全性要求：攻击者不能区分开二者，就是说一个安全的分组密码和随即置换上不可区分

![image-20240511171515309](assets\image-20240511171515309.png)







## AES

明文128bit

密钥为128/192/256 bit

![image-20240511180541240](assets\image-20240511180541240.png)

![image-20240511180552279](assets\image-20240511180552279.png)









## Stream ciphers

设G是PRG，PRG的输出G(k)代替了原来的随机密钥，改造后的一次一密称为流密码

这里使用了PRG的输出Gk代替了原来的随机密钥，可以看出，k是PRG中的种子，在流密码中当作密钥使用

PRG的作用是把种子换成一个很长很长的输出，然后在和明文异或得到密文

![image-20240510142428185](assets\image-20240510142428185.png)

安全性

![image-20240510142707378](assets\image-20240510142707378.png)

### 理解2

流密码是一种加密算法，与分组密码不同，它不是将输入分成固定大小的块进行处理，而是将输入流与密钥流按位进行加密。以下是流密码的解释：

- 从我们定义的角度来看，伪随机生成器有一些限制：
  - 它们产生固定长度的输出。
  - 它们一次性产生输出。
- 在实践中，流密码被广泛使用。
  - 可以看作是按需生成“无限”伪随机比特流。
  - 更灵活，更高效。

流密码包括两个高效的**deterministic algorithms (Init, Next)**：

- Init 接受一个种子 s（和可选的初始化向量 IV），输出初始状态 st。
- Next 接受当前状态 st，并输出一个比特 y 和更新后的状态 st'。
  - 在实践中，y 通常是一个块而不是一个比特。

通过使用（Init，Next），可以从初始种子/初始化向量生成任意数量的输出比特。

一个流密码在输出流（从均匀种子生成）是伪随机的情况下被认为是安全的，即使输出流的长度有多长（只要是多项式长度）。而且，从分组密码很容易构造流密码。

![image-20240512143441714](assets\image-20240512143441714.png)

• A **stream cipher** is ***secure*** if the output stream  (from a uniform seed) is **pseudorandom**

## Modes of operation

Stream-cipher modes of operation

– Synchronized

– Unsynchronized

### Synchronized mode

![image-20240511184005197](assets\image-20240511184005197.png)

同步模式是一种加密模式**，其中发送方和接收方维护状态（即，它们具有状态），并且必须保持同步**。在有限时间的通信会话中，发送方和接收方都在线，并且消息按顺序接收，而且不会被丢弃，这种情况下使用同步模式是合理的。

优缺点

- Advantages
  - Stream cipher does not need to support an IV
  - *No* ciphertext expansion
- Disadvantages
  - Stateful
  - Assumes messages arrive in order; never dropped

### Unsynchronized mode

![image-20240511184042651](assets\image-20240511184042651.png)

不同步模式是一种加密模式，其特点如下：

- 选择随机的初始化向量（IV）来加密下一条消息。
- 类似于我们之前看到的第一个具有选择明文安全性的方案。
  - 但是“本地化”处理任意长度的消息，并且具有更好的密文扩展性。

## Block-cipher modes  of operation

**分组密码的工作模式**

分组密码只能处理固定长度的明文分组，实际上，要加密的分组往往多于一个明文分组

![image-20240511171636717](assets\image-20240511171636717.png)

如何利用分组密码保证消息整体安全性

分组密码的工作模式 (Mode of operation)。它与密钥重复使用问题相关。  

### ECB

![image-20240512144248208](assets\image-20240512144248208.png)

**ECB不安全，不是语义安全，更不是CPA安全**

在语义安全性模型下，很容易找到一个多项式时间的攻击方法

![image-20240511171913837](assets\image-20240511171913837.png)

产生一个具有两个分组的消息m0和m1（各自产生的两个分组内容不相同）

攻击者把这两个消息发给挑战者

挑战者采用ECB模式加密其中一个，并且返回相应的密文

很明显，消息是两个分组的，明文也是两个分组的c

![image-20240511172159102](assets\image-20240511172159102.png)

根据 c[0] 和 c[1] 是否相等，A 就能百分之百地知道自己处于哪个实验。也即，当它俩相等时，A 输出 0 表示自己处于 EXP(0)；不相等时，A 输出1表示自己处于 EXP(1)。

 A的优势是多少呢？

在 EXP(0) 中，A 绝不会输出 1，所以 Pr[W0]=0；而在 EXP(1) 中，A 一定会输出 1，所以 Pr[W1]=1。所以，Adv=|Pr[W0] – Pr[W1]| = |0-1|=1 是不可忽略的。 

![image-20240511172229648](assets\image-20240511172229648.png)



## CTR

CTR，计数器模式，分组密码工作模式之一

**能达到CPA安全性**

设 F 是一个定义在 (K, X, Y) 上的 **PRF**，其中 X={0,…,N-1}, Y={0,1}^n。以 F 为基本模块，利用 CTR 模式可以构造一个新的对称加密体制，它可以处理长度超过n 的明文。

### 加密过程

![image-20240512150630048](assets\image-20240512150630048.png)

首先选择一个 IV∈X。**IV本质上是计数器**，先计算 F(k, IV)（也就是F和密钥k处理IV），将其与第一个明文分组 m[1] 的异或，所得便为密文分组 c[1]；

然后依次计算 F(k, IV+1)、F(k, IV+2)等，并按前述方法与此后的所有明文分组分别异或，便得对应的密文分组。

需要注意的是，为了能够成功解密，必须把 IV 也发送给解密者。为描述方便，把 IV 写成 c[0]，发送时作为密文的第一个分组。

解密过程与加密类似，只不过在计算出 F(k, IV)、F(k, IV+1) 等密钥流之后与密文分组异或，从而得到相应的明文分组。

从加解密过程可以看出，CTR 模式用的是流密码的思想，F(k, IV)、F(k, IV+1) 等充当密钥流。

  **CTR 模式的加解密过程可以并行执行**，吞吐量仅受可并行数量的限制；



加密每个明文时需要选择不同的 IV，因此给定相同的明文，由于选用的 IV 不同，对应的密文也会不一样，

CTR 是CPA 安全证明

![image-20240512151055463](assets\image-20240512151055463.png)

## CBC 

CBC，密码分组链模式，分组密码工作模式之一

**能达到CPA安全性**

设（E,D）是定义在（K,X）上的PRP，X={0,1}^n，n为分组长度。

利用CBC模式可以构造出一个新的兑成加密体制，可以处理长度超过n的明文

![image-20240512145348810](assets\image-20240512145348810.png)

### 加密过程

![image-20240512145619032](assets\image-20240512145619032.png)

加密时，选择一个初始向量IV，IV的长度和明文分组长度相等。

先计算IV和第一个明文分组m[1]的异或值，再把结果用E加密，得到密文分组c[1]

此后的所有明文分组都要与全一个密文分组进行异或，再用E加密得到对应密文分组

为了成功解密，IV也要发送给解密者，把IV记错c[0]。

加密每个明文，需要选择不同的IV，因此给定相同的明文，选用的IV不同

### 解密过程

![image-20240512145724352](assets\image-20240512145724352.png)

解密时，可以对每个密文分组分别用D解密，然后再将解密结果与是一个密文分组进行异或，得到对应明文分组

### 说明

   (1) 密文会比明文长，因为通常需要把 IV 发送给解密者。

   (2) 加密需要串行执行，这是因为在没有获得上一个明文分组对应的密文分组前，下一个明文分组是无法被加密的。

   (3) 解密可以并行执行。这是因为，虽然解密每个密文分组时需要与前一个密文分组进行异或，但是所有密文分组在解密时都是已经知道的了。

   (4)  CBC模式**需要使用PRP，**这是因为加密时要使用E，**解密时使用其逆置换D**。（后文介绍CTR模式时，大家会看到，**CTR模式只需要PRF，**因为加解密不需要逆置换。）  