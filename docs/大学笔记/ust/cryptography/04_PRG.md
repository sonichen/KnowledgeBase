## 随机序列和伪随机序列

### Random

一个序列是随机的，它必须满足两个条件：

- 每个比特的产生概率都是1/2；
- 每个比特的产生与其他比特的产生都是统计上相互独立的。

也就是说，序列中每个比特都是等概率产生的，而且每个比特的产生都和其他比特没有半毛钱关系。一个序列是不是随机的，**和它长什么样没有关系，而取决于它的产生方式**。

If we generate a uniform 16-bit string, each of  the above occurs with probability 2^-16

### Pseudorandom

密码学上所说的伪随机序列指的是：**如果一个序列能够和等长的随机序列不可区分的话，那么它就是伪随机序列**。相当于说，伪随机序列能**以假乱真**，和真正随机的序列区分不开。



## PRG定义

PRG是一种有效的、确定性的算法，它**将一个较短的、均匀的种子扩展为一个较长的、伪随机的输出**

设G是一个高效的确定性函数（对于相同的输入，输出都是一样的），输入长度s（输入称为种子，输入空间称为种子空间），输出长度n，**s远远小于n**,则G是一个PRG

![image-20240510142239906](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510142239906.png)

 对于这个定义，我们解释一下

 (1) PRG是高效可计算的，也即给定其输入，它可以很快地产生输出。

 (2) PRG是确定性函数，也即对于相同的输入，它的输出都是一样的。

 (3) PRG的输入长度s远远小于其输出长度n。

## PRG的安全性

**思考以下**

可忽略的 不可忽略的
可区分的 不可区分的

**先思考PRG的安全性和不可区分性之间的关系**

流密码虽然和PRG关系紧密，但是**PRG的安全性和流密码的安全性不能等价**

PRG的输出应该是伪随机的，所以**PRG的安全性就要求其输出必须和等长的随机序列不可区分 以便以假乱真**

### **认识不可区分**

图灵测试

> 搞两个小屋子，一个屋子里是人，另一个里是计算机，我们称他俩为被测试者。人们不知道人和计算机在哪个屋子，但可以对屋里的被测试者进行提问，并得到相应的回答。经过一系列问答以后，人们可以猜哪个屋里是计算机。
>
>    如果一大票人都猜错了，那么就说计算机通过了图灵测试（也即它具有智能）。
>
> 或者说，计算机和人不可区分。
>
>  所以，刻画不可区分的方法就是通过给出两个关在小黑屋里的东西，大家经过测试分不清谁是谁，那它俩就是不可区分的。

密码学的不可区分和图灵测试很像

### PRG安全模型

如图：

- A是攻击者attacker，A只能看到小黑屋返回的序列r，A的任务就是根据 r 猜测自己到底是处于实验EXP(0)还是实验EXP(1)，并输出自己的猜测b。

- 两个实验，也就是两个小黑屋，各有一个挑战者challenger，EXP(0)是PRG黑盒，1是随机序列黑盒

  -  首先

    - 一个挑战者执行G，他随机选择种子k，并将 G(k) 的执行结果 r 返回给 A。

    - 另一个挑战者随机选择r，并将之直接返回给 A。

  - 然后，随机选择一个小黑屋，放在A面前，A并不知道自己面对的是哪一个屋： 

    - 如果A面对的是PRG那个屋，我们称之为实验EXP(0)。

    - 如果A面对的是随机序列那个屋，我们称之为实验EXP(1)。

**如果攻击者无法区分这两个实验，就不能区分PRG输出和等长随机序列**

![image-20240510150029353](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150029353.png)



我们考虑在不同实验中，攻击者返回’相同猜测结果‘的概率之间的差异是多少？

W0表示攻击者在EXP(0)中猜测后返回1的概率，W1表示攻击者在EXP(1)中猜测后返回1的概率

假设有一个攻击者得到的差值为0，**说明他在不同实验中输出相同猜测结果的概率是相等的，说明他分不清自己在哪个实验，也就不能区分PRG输出和等长随机序列**

![image-20240510150529325](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150529325.png)

现在可以存在差异，差异（优势）可以忽略，攻击者还是无法区分开，那么不能区分PRG输出和等长随机序列

![image-20240510150559908](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150559908.png)

有的时候，某些攻击者的优势并不等于0，但只要优势（Adv = |Pr[W0] – Pr[W1]|）是可忽略的，那么攻击者虽然能从小黑屋的返回值中分析出一点儿EXP(0)和EXP(1)的差异，但这个差异实在是太小了，以至于可以忽略，所以在实际中他并不能区分开EXP(0)和EXP(1)。在这种情况下，我们仍认为G是安全的，它仍能以假乱真。 

### PRG安全性

![image-20240510150232902](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150232902.png)









## PRG的不可预测性unpredictability

任何攻击者在获得G输出的任意一些连续比特后，都难以成功预测下一个比特是什么，G就具有不可预测性。

### 定义

![image-20240512104956634](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240512104956634.png)

首先，挑战者随机选择一个密钥 k，产生 G(k) 的输出，记为 r。

然后，攻击者 A 选择一个i发送给挑战者，挑战者返回 G(k) 的前 i 个比特 r[0, …, i-1]。

最后，A 根据已知的 i 个比特猜测下一个比特 r[i] 是 0 还是 1，其猜测记为 t。

如果 t=r[i]，A 猜测成功；反之，猜测失败。 

**优势 Adv := |Pr[A 猜测成功] – 1/2| 如何解释**

注意，r[i] 的取值只有两种可能性（0或1）。

如果 A 瞎猜，抛硬币听天由命，Pr[A 猜测成功] 等于1/2。此时 Adv=0，表明 A 的猜测方法没有任何优势可言。

如果 Pr[A 猜测成功] 大于 1/2 或小于 1/2（也即 Pr[A 猜测成功] 偏离1/2），表明 A 的猜测方法具有一定的优势，而且 |Pr[A 猜测成功] – 1/2| 越大，优势越大。 

![image-20240510152716827](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510152716827.png)

PRG的不可预测性和安全性是等价的

### 与安全性之间的关系  

安全性和不可预测性之间是否存在某种联系呢？

**PRG的安全性和不可预测性其实是等价**。也即，如果一个PRG是安全的，它一定是不可预测的；反之，如果一个PRG是不可预测的，它一定是安全的。



