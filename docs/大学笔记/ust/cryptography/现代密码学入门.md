学习材料

【现代密码学入门||（重置版）香农到底做了什么，密码学被他玩得风生水起】 https://www.bilibili.com/video/BV1q3411E7TX/?share_source=copy_web&vd_source=f8d51e18721c16e2511bfc62cc8f0e29

## 01 密码学和香农

香农：用概率论研究密码的安全性

密码：分为古典密码和现代密码；古代近代二战使用的密码属于古典密码

## 02 完善保密性

- 对称密码：通信双方使用相同密钥
- 公钥密码（非对称密码）：通信双方使用不同密码

### 对称密码Symmetric Encryption

设（E,D）是对称加密方案，E是加密算法，D是解密算法。

- 加密：E(k,m)=c，输入密钥k和明文m，输出密文c

- 解密：D(k,c)=m，输入密钥k和密文c，输出明文m


(E,D)是定义在（K,M,C）上的对称加密方案，![image-20240321112705869](assets\image-20240321112705869.png)

- m属于M（明文）
- k属于K（密钥）
- c属于C（密文）



**密钥是安全性的构建**

为什么需要密钥？密钥匙安全性的关键

我们希望，即使攻击者知道了密码系统的全部运作细节，只要密码没有泄露，系统仍是安全的。

所以在分析安全性时，总是假设攻击者知道了密码系统的全部运作细节，但不知道密钥



### 完善保密性Perfect Secrey

如果任意两个明文m0,m1∈M，给定任意一个密文c，每个明文被加密成c的概率时相等的（明文空间中所有明文被加密成该密文的概率是一样的）。

则（E,D）具有完善保密性，其中k属于K是随机的。



**密文不会泄露明文的任何信息**

攻击者窃听到任意一个密文后，该密文到底是加密哪个明文得来的呢？既然每个明文加密成该密文的概率一样，那么攻击者不知道该密文对应哪个明文



**一个对称加密方案是完善保密的，那就是安全的**



**注意事项**

- 唯密文攻击无效（其他类型攻击未必安全）：考虑的是唯密文攻击，也就是攻击者手里只有窃听到的密文（密文不泄露明文信息）
- 任何信息指的是明文内容，不包括明文长度和发送时间

**完整定义**

![image-20240510122608295](assets\image-20240510122608295.png)



**等价定义**

给定任意密文c，对于明文空间中所有明文，如果把每个明文加密成c的密钥数量是相等的，都是N，那么加密方案就算完善保密的

![image-20240510123318449](assets\image-20240510123318449.png)



## 03 一次一密OTP

原理和证明一次一密具有完善保密性

一次一密有多个形式，这里谈及比特串形式

满足完善保密性，加解密只需要异或操作

### 比特串形式

明文m，密文c和密钥k都是**长度相等的比特串**（任何message和数字都可以表示成比特串形式），注意密钥是随机的

加密：明文异或密钥得到密文

解密：密文和密钥异或得到明文

![image-20240510122943032](assets\image-20240510122943032.png)



正式写法

![image-20240510123012648](assets\image-20240510123012648.png)

### 满足完善保密性

如果一次一密是完善保密的，对于任何密文，明文空间中所有明文被加密成该密文的概率一样。

也就是要满足

![image-20240321115450976](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240321115450976.png)

需要证明，给定任意密文c，把每个明文加密成c的密钥的数量都是相等的



![image-20240321120403093](assets\image-20240321120403093.png)

## 04 香农定理

如果一个加密方案具有完善保密性，那么密钥**至少要和明文一样长**（由此可知，满足完善保密性的加密方案不实用）

为什么一次一密不实用？

- 密钥至少和明文一样长，密钥空间至少和明文空间一样大
- 密钥不能重复使用
- 密钥必须是随机的

![image-20240321120549045](assets\image-20240321120549045.png)

![image-20240321120729716](assets\image-20240321120729716.png)

![image-20240321120800054](assets\image-20240321120800054.png)



小于等于

![image-20240321120817461](assets\image-20240321120817461.png)

![image-20240321120848223](assets\image-20240321120848223.png)

## 05 改造一次一密

**思考**

完善保密性 →具有无限计算资源也无法获得明文的任何信息(无条件安全性)

香农定理 →密钥不能短于明文(不实用)

**一次一密的优点**

加解密简单，计算速度快

**改造一次一密:**

- 更加实用:可以用短密钥加密长消息（短消息无法满足香农定理，会泄露明文信息，难以保证安全性）
- 保证安全性

**思考攻击方式**

完善保密性：无限计算资源攻击者

实际应用：有限计算资源得到攻击者（所以构建’计算上安全‘的密码方案就好）

**思考设计**


只要加密方案在这个定义下是安全的 那么有限计算资源的攻击者就拿它没办法

设计一种加密方案，可以用**短密钥加密长消息**，在面对实际的攻击者时(计算资源有限)，没必要达到完善保密性，即**使密文泄露了明文的信息，只要这些信息对攻击者的帮助是可忽略就没关系。**

做两件事

1. 定义新的安全性:语义安全性
2. 改造一次一密:流密码



## 06 流密码-如何用短消息加密长消息

基本原理：利用一个伪随机生成器（PRG，伪随机生成器能和真正的随机序列以假乱真，难以区别）将短密钥加工厂长密钥，再用长密钥和明文逐比特异或，就可以得到密文，反之与密文逐比特异或得到明文

![image-20240510142022159](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510142022159.png)



### PRG定义

设G是一个高效的确定性函数（对于相同的输入，输出都是一样的），输入长度s（输入称为种子，输入空间称为种子空间），输出长度n，s远远小于n,则G是一个PRG

![image-20240510142239906](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510142239906.png)



设G是PRG，改造后的一次一密称为流密码

这里使用了PRG的输出Gk代替了原来的随机密钥，可以看出，k是PRG中的种子，在流密码中当作密钥使用

PRG的作用是把种子换成一个很长很长的输出，然后在和明文异或得到密文

![image-20240510142428185](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510142428185.png)

安全性

![image-20240510142707378](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510142707378.png)

## 07 PRG的安全性

**思考以下**

可忽略的 不可忽略的
可区分的 不可区分的

**先思考PRG的安全性和不可区分性之间的关系**

流密码虽然和PRG关系紧密，但是PRG的安全性和流密码的安全性不能等价



PRG的输出应该是伪随机的，所以PRG的安全性就要求其输出必须和等长的随机序列不可区分 以便以假乱真



### **不可区分概念**

EXP(0)是PRG黑盒，1是随机序列黑盒

输出b，b=0表示攻击者猜测自己在EXP(0)，反之

如果攻击者无法区分这两个实验，就不能区分PRG输出和等长随机序列

![image-20240510150029353](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150029353.png)



我们考虑在不同实验中，攻击者返回’相同猜测结果‘的概率之间的差异是多少？

W0表示攻击者在EXP(0)中猜测后返回1的概率，W1表示攻击者在EXP(1)中猜测后返回1的概率

假设有一个攻击者得到的差值为0，说明他在不同实验中输出相同猜测结果的概率是相等的，说明他分不清自己在哪个实验，也就不能区分PRG输出和等长随机序列

![image-20240510150529325](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150529325.png)

现在可以存在差异，差异（优势）可以忽略，攻击者还是无法区分开，那么不能区分PRG输出和等长随机序列

![image-20240510150559908](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150559908.png)





![image-20240510150232902](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510150232902.png)









## 08 PRG的不可预测性unpredictability

1. 不可预测性的现实意义
2. 不可预测性的定义
3. 不可预测性和安全性的关系

任何攻击者在获得G输出的任意一些连续比特后，都难以成功预测下一个比特是什么，G就具有不可预测性。

![image-20240510152716827](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510152716827.png)

PRG的不可预测性和安全性是等价的





## 09 语言安全性

对称加密方案的攻击类型

- 唯密文攻击:攻击者只有一些密文
- 已知明文攻击:攻击者还知道密文所对应的明文
- 选择明文攻击:攻击者可以自己选择一些明文，并获得对应的密文
- 选择密文攻击:攻击者可以自己选择一些密文，并获得相应的明文

完善保密性:唯密文攻击下的定义
语义安全性:选择明文攻击下的定义

![image-20240510153011354](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510153011354.png)

两个挑战者和两个实验

实验0中加密信息m0，实验1加密信息m1，两个实验会返回密文c，攻击者要判断c是m0还是m1得到的



![image-20240510153741924](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510153741924.png)

![image-20240510153752141](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510153752141.png)

![image-20240510153805088](D:\Workplace\github\soni_notes\docs\大学笔记\ust\cryptography\assets\image-20240510153805088.png)

## 10 流密码具有语义安全性

## 11 反证法

## 12 混合论证